// ============================================================
// Package singleflight - 重复函数调用抑制机制
// ============================================================
// Package singleflight 提供了重复函数调用抑制机制
//
// 核心功能：
// 对于相同的 key，确保同时只有一个函数在执行
// 其他并发调用者会等待第一个调用完成，然后共享结果
//
// 使用场景：
// - 缓存未命中时的数据加载（groupcache 的核心用途）
// - 防止缓存击穿（大量并发请求同一个不存在的 key）
// - 减少对后端数据库/API 的重复请求
//
// 例子：
// 假设 100 个 goroutine 同时请求相同的 key：
// - 没有 singleflight：100 个数据库查询
// - 有 singleflight：1 个数据库查询，结果共享给 100 个 goroutine
package singleflight

import "sync"

// ============================================================
// call - 正在进行或已完成的 Do 调用
// ============================================================
// call 表示一个正在进行中或已完成的函数调用
type call struct {
	wg  sync.WaitGroup // 用于等待函数执行完成
	val interface{}    // 函数的返回值
	err error          // 函数的错误（如果有）
}

// ============================================================
// Group - 工作组
// ============================================================
// Group 表示一类工作，并形成一个命名空间
// 在这个命名空间中，工作单元可以通过重复抑制机制执行
//
// 设计：
// - 每个 Group 维护一个 key -> call 的映射
// - 相同 key 的并发调用会等待第一个调用完成
// - 不同 key 的调用可以并发执行
type Group struct {
	mu sync.Mutex       // 保护 m
	m  map[string]*call // 延迟初始化，存储正在进行的调用
}

// ============================================================
// Do - 执行并返回给定函数的结果
// ============================================================
// Do 执行并返回给定函数的结果，确保对于给定的 key
// 同时只有一个执行在进行中
//
// 参数：
//   key: 标识这个工作单元的键
//   fn: 要执行的函数
//
// 返回值：
//   interface{}: fn 的返回值
//   error: fn 的错误
//
// 行为：
// - 如果有重复调用进来，重复调用者会等待原始调用完成
// - 所有调用者接收相同的结果（值和错误）
//
// 工作流程示例：
// T0: goroutine 1 调用 Do("key1", fn)
//     - 没有其他调用，创建 call，执行 fn
// T1: goroutine 2 调用 Do("key1", fn)
//     - 发现 key1 已经在执行，等待 goroutine 1 完成
// T2: goroutine 3 调用 Do("key1", fn)
//     - 发现 key1 已经在执行，等待 goroutine 1 完成
// T3: goroutine 1 的 fn 完成
//     - goroutine 2 和 3 都接收到相同的结果
func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) {
	// 1. 获取锁，检查是否已有相同 key 的调用在进行
	g.mu.Lock()

	// 延迟初始化 map
	if g.m == nil {
		g.m = make(map[string]*call)
	}

	// 检查是否已经有相同 key 的调用在进行
	if c, ok := g.m[key]; ok {
		// 已有调用在进行，释放锁并等待
		g.mu.Unlock()
		// 等待原始调用完成
		c.wg.Wait()
		// 返回原始调用的结果
		return c.val, c.err
	}

	// 2. 没有重复调用，创建新的 call
	c := new(call)
	c.wg.Add(1)   // 设置等待计数为 1
	g.m[key] = c  // 注册这个调用
	g.mu.Unlock() // 释放锁，允许其他 goroutine 检查

	// 3. 执行函数（在锁外执行，避免阻塞其他操作）
	c.val, c.err = fn()
	c.wg.Done() // 通知所有等待者函数已完成

	// 4. 清理：从 map 中移除这个调用
	// 这允许未来相同 key 的调用重新执行函数
	g.mu.Lock()
	delete(g.m, key)
	g.mu.Unlock()

	// 5. 返回结果
	return c.val, c.err
}

// ============================================================
// 关键设计考虑
// ============================================================
//
// 1. 为什么在执行 fn 前释放锁？
//    - fn 可能很慢（如网络请求、数据库查询）
//    - 如果持有锁，会阻塞其他 key 的 Do 调用
//    - 只有 m 的访问需要保护，fn 的执行不需要
//
// 2. 为什么执行完后删除 key？
//    - 避免 map 无限增长
//    - 允许后续相同 key 的调用重新执行（数据可能已过期）
//    - 与 groupcache 的使用模式匹配：每次缓存未命中都应重新加载
//
// 3. 如何处理错误？
//    - 错误也会被共享给所有等待者
//    - 如果第一个调用失败，所有等待者都会收到相同的错误
//    - 这是合理的：避免重复失败的昂贵操作
//
// 4. 内存屏障和可见性
//    - sync.WaitGroup 提供了必要的内存屏障
//    - Wait() 返回时，保证能看到 Done() 之前的所有写入
//    - 因此等待者能看到 c.val 和 c.err 的正确值
//
// ============================================================
