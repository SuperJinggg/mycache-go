// ============================================================
// Package consistenthash - 一致性哈希实现
// ============================================================
// Package consistenthash 提供了环形哈希（ring hash）的实现
//
// 一致性哈希的核心概念：
//
// 1. 哈希环：
//   - 将哈希值空间想象成一个环（0 到 2^32-1，首尾相连）
//   - 节点和 key 都映射到这个环上
//
// 2. 虚拟节点（Replicas）：
//   - 每个真实节点在环上有多个虚拟节点
//   - 例如：节点 "nodeA" 可能有虚拟节点 "0nodeA", "1nodeA", "2nodeA"...
//   - 虚拟节点越多，负载分布越均匀
//
// 3. Key 定位：
//   - 计算 key 的哈希值
//   - 在环上顺时针查找第一个大于等于该哈希值的虚拟节点
//   - 返回该虚拟节点对应的真实节点
//
// 4. 为什么叫"一致性"？
//   - 当节点增加或减少时，只有少量 key 需要重新映射
//   - 例如：100 个节点中增加 1 个，平均只有 1/101 的 key 需要迁移
//   - 传统取模方式（hash(key) % n）会导致几乎所有 key 重新映射
//
// 应用场景：
// - 分布式缓存（如 groupcache）
// - 分布式存储
// - 负载均衡
package consistenthash

import (
	"hash/crc32"
	"sort"
	"strconv"
)

// ============================================================
// Hash - 哈希函数类型
// ============================================================
// Hash 是哈希函数的类型定义
// 接受字节数组，返回 32 位无符号整数
type Hash func(data []byte) uint32

// ============================================================
// Map - 一致性哈希环
// ============================================================
// Map 表示一致性哈希环
type Map struct {
	hash     Hash           // 哈希函数
	replicas int            // 每个真实节点的虚拟节点数
	keys     []int          // 排序后的哈希值数组（哈希环）
	hashMap  map[int]string // 哈希值到真实节点名称的映射
}

// ============================================================
// New - 创建新的一致性哈希环
// ============================================================
// New 创建一个新的 Map 实例
//
// 参数：
//
//	replicas: 每个真实节点的虚拟节点数（副本数）
//	         - 越大负载越均衡，但内存占用越多
//	         - 典型值：50-200
//	fn: 哈希函数
//	    - 如果为 nil，默认使用 crc32.ChecksumIEEE
//	    - CRC32 速度快，分布均匀，适合此场景
func New(replicas int, fn Hash) *Map {
	m := &Map{
		replicas: replicas,
		hash:     fn,
		hashMap:  make(map[int]string),
	}
	// 如果没有指定哈希函数，使用默认的 CRC32
	if m.hash == nil {
		m.hash = crc32.ChecksumIEEE
	}
	return m
}

// ============================================================
// IsEmpty - 检查环是否为空
// ============================================================
// IsEmpty 返回 true 如果没有可用的节点
func (m *Map) IsEmpty() bool {
	return len(m.keys) == 0
}

// ============================================================
// Add - 添加节点到哈希环
// ============================================================
// Add 添加一些节点（keys）到哈希环
//
// 工作流程：
// 1. 对每个真实节点，创建 replicas 个虚拟节点
// 2. 计算每个虚拟节点的哈希值
// 3. 将哈希值添加到环上
// 4. 建立哈希值到真实节点的映射
// 5. 对所有哈希值排序（维护环的有序性）
//
// 例子：
// 假设 replicas = 3，添加节点 "nodeA"
// 创建虚拟节点：
//   - hash("0nodeA") -> 1234567
//   - hash("1nodeA") -> 7654321
//   - hash("2nodeA") -> 3456789
//
// 都映射回 "nodeA"
func (m *Map) Add(keys ...string) {
	// 遍历每个真实节点
	for _, key := range keys {
		// 为每个真实节点创建 replicas 个虚拟节点
		for i := 0; i < m.replicas; i++ {
			// 计算虚拟节点的哈希值
			// 虚拟节点名称：strconv.Itoa(i) + key
			// 例如："0nodeA", "1nodeA", "2nodeA"
			hash := int(m.hash([]byte(strconv.Itoa(i) + key)))
			// 将哈希值添加到环上
			m.keys = append(m.keys, hash)
			// 建立哈希值到真实节点的映射
			m.hashMap[hash] = key
		}
	}
	// 排序哈希值，维护环的有序性
	// 排序后可以使用二分查找，时间复杂度 O(log n)
	sort.Ints(m.keys)
}

// ============================================================
// Get - 获取 key 应该分配到的节点
// ============================================================
// Get 获取哈希环上距离提供的 key 最近的节点
//
// 工作流程：
// 1. 计算 key 的哈希值
// 2. 在环上二分查找第一个 >= hash(key) 的虚拟节点
// 3. 如果找不到（环绕情况），返回第一个虚拟节点
// 4. 返回该虚拟节点对应的真实节点
//
// 可视化示例：
//
// 哈希环（已排序）：
//
//	 1000  3000  5000  7000  9000
//	  |     |     |     |     |
//	nodeA nodeB nodeC nodeA nodeB
//
// 查找 key（hash(key) = 4500）：
//   - 二分查找找到第一个 >= 4500 的位置：5000
//   - 返回 hashMap[5000] = "nodeC"
//
// 查找 key（hash(key) = 9500）：
//   - 二分查找找不到 >= 9500 的位置
//   - 环绕到开头，返回 hashMap[1000] = "nodeA"
func (m *Map) Get(key string) string {
	// 检查环是否为空
	if m.IsEmpty() {
		return ""
	}

	// 1. 计算 key 的哈希值
	hash := int(m.hash([]byte(key)))

	// 2. 二分查找第一个 >= hash 的虚拟节点
	// sort.Search 返回满足 f(i) == true 的最小索引 i
	// 如果没有满足条件的，返回 len(m.keys)
	idx := sort.Search(len(m.keys), func(i int) bool {
		return m.keys[i] >= hash
	})

	// 3. 处理环绕情况
	// 如果 idx == len(m.keys)，说明 hash 大于所有虚拟节点
	// 需要环绕到第一个虚拟节点
	if idx == len(m.keys) {
		idx = 0
	}

	// 4. 返回虚拟节点对应的真实节点
	return m.hashMap[m.keys[idx]]
}

// ============================================================
// 一致性哈希的优势分析
// ============================================================
//
// 1. 节点增加的影响：
//    假设有 N 个节点，增加 1 个节点
//    - 一致性哈希：平均 1/(N+1) 的 key 需要迁移
//    - 传统取模：平均 N/(N+1) 的 key 需要迁移
//
// 2. 节点减少的影响：
//    假设有 N 个节点，减少 1 个节点
//    - 一致性哈希：该节点的 key 迁移到下一个节点
//    - 传统取模：几乎所有 key 都需要重新映射
//
// 3. 负载均衡：
//    - 虚拟节点数越多，负载分布越均匀
//    - 理论上，replicas -> ∞ 时，接近完美均衡
//    - 实践中，replicas = 50-200 就足够好
//
// 4. 时间复杂度：
//    - Add: O(replicas * log(total_nodes * replicas)) [排序]
//    - Get: O(log(total_nodes * replicas)) [二分查找]
//
// 5. 空间复杂度：
//    - O(total_nodes * replicas)
//
// ============================================================
